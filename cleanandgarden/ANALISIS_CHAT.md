# üí¨ AN√ÅLISIS: QU√â FALTA EN EL SISTEMA DE CHAT

**Fecha de an√°lisis:** 17 de Octubre 2025  
**Estado:** Identificaci√≥n de tareas pendientes

---

## üéØ RESUMEN EJECUTIVO

El sistema de chat tiene:
- ‚úÖ Endpoints REST b√°sicos en backend
- ‚úÖ Interfaz de usuario en frontend (parcial)
- ‚ùå **FALTA: Conexi√≥n en tiempo real (WebSocket/SSE)**
- ‚ùå **FALTA: Persistencia de mensajes en BD**
- ‚ùå **FALTA: Notificaciones en tiempo real**
- ‚ùå **FALTA: Integraci√≥n front-back**

---

## üìã ESTADO ACTUAL DEL CHAT

### Backend (Express) - PARCIAL ‚úÖ‚ùå

#### Endpoints Existentes:
```typescript
‚úÖ GET  /conversaciones              - Listar conversaciones del usuario
‚úÖ GET  /conversaciones/:id/mensajes - Obtener mensajes de una conversaci√≥n
‚úÖ POST /conversaciones              - Crear conversaci√≥n con otro usuario
‚úÖ POST /mensajes                    - Enviar mensaje
‚úÖ GET  /usuarios/buscar             - Buscar usuarios para chatear
```

#### Problemas:
- ‚ùå No hay **WebSocket** para mensajes en tiempo real
- ‚ùå No hay **Server-Sent Events (SSE)** para notificaciones
- ‚ùå No hay endpoint para **eliminar/editar mensajes**
- ‚ùå No hay endpoint para **marcar como le√≠do**
- ‚ùå No hay **autenticaci√≥n de Socket**
- ‚ùå No hay **validaci√≥n de mensajes vac√≠os**

---

### Frontend (Next.js) - INCOMPLETO ‚ùå

#### Componentes Existentes:
```
web/src/app/chat/page.tsx              ‚úÖ P√°gina de chat (UI b√°sica)
web/src/components/realtime-chat.tsx   ‚ö†Ô∏è  Componente realtime (pero no conectado)
web/src/components/chat-message.tsx    ‚úÖ Componente individual de mensaje
web/src/hooks/use-realtime-chat.tsx    ‚ùå Hook incompleto (necesita WebSocket)
web/src/hooks/use-chat-scroll.tsx      ‚úÖ Hook para scroll
```

#### Problemas:
- ‚ùå El hook `useRealtimeChat` no est√° conectado a WebSocket real
- ‚ùå No hay conexi√≥n con endpoints REST del backend
- ‚ùå No carga mensajes anteriores de BD
- ‚ùå No hay persistencia de conversaciones
- ‚ùå No hay notificaciones visuales
- ‚ùå No hay indicador de "escribiendo..."
- ‚ùå No hay estados de entrega (enviado, le√≠do)
- ‚ùå No hay integraci√≥n con Supabase Realtime

---

## üì¶ M√ìDULOS QUE NECESITAS IMPLEMENTAR

### 1Ô∏è‚É£ **WebSocket Server** (Backend)
**Archivo a crear:** `backend/src/lib/websocket.ts`

**Responsabilidades:**
- Mantener conexiones de usuarios
- Propagar mensajes en tiempo real
- Manejar desconexiones
- Autenticar conexiones con JWT
- Notificar cuando usuario est√° escribiendo

**Pseudoc√≥digo:**
```typescript
// backend/src/lib/websocket.ts
import WebSocket from 'ws';

class ChatServer {
  private ws: WebSocket.Server;
  private connections = new Map(); // userId -> Set<WebSocket>
  
  start(port: number) { }
  authenticate(token: string) { }
  broadcastMessage(conversationId, message) { }
  notifyTyping(conversationId, userId) { }
  notifyMessageRead(conversationId, messageId) { }
}
```

---

### 2Ô∏è‚É£ **WebSocket Integration en Express** (Backend)
**Archivo a modificar:** `backend/src/server.ts`

**Cambios necesarios:**
- Integrar WebSocket server con Express
- Manejar autenticaci√≥n de conexiones
- Emitir eventos cuando se env√≠e mensaje
- Persistir mensajes en BD

**Pseudoc√≥digo:**
```typescript
// En server.ts
import { ChatServer } from './lib/websocket';

const chatServer = new ChatServer();

// Cuando se env√≠a un mensaje
app.post('/mensajes', authMiddleware, async (req, res) => {
  // Crear mensaje en BD
  const mensaje = await prisma.mensaje.create(...);
  
  // Emitir por WebSocket
  chatServer.broadcastMessage(conversacionId, mensaje);
  
  res.json(mensaje);
});

// Iniciar WebSocket server
const wsServer = chatServer.start(5001); // O mismo puerto con upgrade
```

---

### 3Ô∏è‚É£ **Hook de Chat con WebSocket** (Frontend)
**Archivo a crear/actualizar:** `web/src/hooks/use-chat-websocket.tsx`

**Responsabilidades:**
- Conectar a WebSocket
- Sincronizar mensajes
- Manejar reconexi√≥n autom√°tica
- Enviar y recibir mensajes
- Indicador de escribiendo

**Pseudoc√≥digo:**
```typescript
// web/src/hooks/use-chat-websocket.tsx
import { useEffect, useState, useCallback } from 'react';

export function useChatWebSocket(conversationId: string) {
  const [messages, setMessages] = useState([]);
  const [isConnected, setIsConnected] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  
  useEffect(() => {
    const ws = new WebSocket(`ws://localhost:5001?token=${token}`);
    
    ws.onopen = () => setIsConnected(true);
    ws.onmessage = (event) => {
      const { type, data } = JSON.parse(event.data);
      if (type === 'message') {
        setMessages(prev => [...prev, data]);
      }
    };
    
    return () => ws.close();
  }, [conversationId]);
  
  const sendMessage = useCallback((text: string) => {
    ws.send(JSON.stringify({
      type: 'message',
      conversationId,
      text
    }));
  }, []);
  
  return { messages, sendMessage, isConnected, isTyping };
}
```

---

### 4Ô∏è‚É£ **Componente de Chat Conectado** (Frontend)
**Archivo a actualizar:** `web/src/components/realtime-chat.tsx`

**Cambios necesarios:**
- Usar el nuevo hook `useChatWebSocket`
- Cargar mensajes iniciales de la API
- Mostrar estado de conexi√≥n
- Indicador de escribiendo
- Estados de entrega

**Pseudoc√≥digo:**
```tsx
// web/src/components/realtime-chat.tsx
export function RealtimeChat({ conversationId, username }) {
  const { messages, sendMessage, isConnected } = useChatWebSocket(conversationId);
  const [initialMessages, setInitialMessages] = useState([]);
  
  // Cargar mensajes del historial
  useEffect(() => {
    fetch(`/api/conversaciones/${conversationId}/mensajes`)
      .then(r => r.json())
      .then(setInitialMessages);
  }, [conversationId]);
  
  return (
    <div>
      <ConnectionStatus connected={isConnected} />
      <MessageList messages={[...initialMessages, ...messages]} />
      <MessageInput onSend={sendMessage} />
    </div>
  );
}
```

---

### 5Ô∏è‚É£ **P√°gina de Chat Actualizada** (Frontend)
**Archivo a actualizar:** `web/src/app/chat/page.tsx`

**Cambios necesarios:**
- Listar conversaciones existentes
- Permitir crear nueva conversaci√≥n
- Seleccionar conversaci√≥n para chatear
- Mostrar chat en tiempo real

**Pseudoc√≥digo:**
```tsx
// web/src/app/chat/page.tsx
export default function ChatPage() {
  const [conversaciones, setConversaciones] = useState([]);
  const [selectedConv, setSelectedConv] = useState(null);
  
  useEffect(() => {
    // Cargar conversaciones
    fetch('/api/conversaciones')
      .then(r => r.json())
      .then(setConversaciones);
  }, []);
  
  return (
    <div className="grid grid-cols-3 gap-4">
      <ConversationsList 
        conversaciones={conversaciones}
        onSelect={setSelectedConv}
      />
      {selectedConv && (
        <RealtimeChat 
          conversationId={selectedConv.id}
          username={user.nombre}
        />
      )}
    </div>
  );
}
```

---

### 6Ô∏è‚É£ **Mensajer√≠a en BD** (Backend)
**Archivo a modificar:** `backend/prisma/schema.prisma`

**Cambios necesarios:** (Ya existe pero necesita verificaci√≥n)

```prisma
model conversacion {
  id                        BigInt @id @default(autoincrement())
  tipo                      String @db.VarChar(20)
  contexto_id               BigInt?
  fecha_creacion            DateTime @default(now())
  
  mensaje                   mensaje[]
  participante_conversacion participante_conversacion[]
}

model mensaje {
  id                BigInt        @id @default(autoincrement())
  conversacion_id   BigInt
  remitente_id      BigInt
  cuerpo            String?
  creado_en         DateTime      @default(now())
  editado_en        DateTime?
  eliminado_en      DateTime?
  
  conversacion      conversacion  @relation(fields: [conversacion_id])
  usuario           usuario       @relation(fields: [remitente_id])
  mensaje_leido     mensaje_leido[]
}

model mensaje_leido {
  id         BigInt @id @default(autoincrement())
  mensaje_id BigInt @unique
  usuario_id BigInt @unique
  leido_en   DateTime @default(now())
  
  mensaje    mensaje @relation(fields: [mensaje_id])
  usuario    usuario @relation(fields: [usuario_id])
}
```

---

## üõ†Ô∏è PLAN DE IMPLEMENTACI√ìN

### Fase 1: WebSocket B√°sico (1-2 d√≠as)
```
1. Crear servidor WebSocket
2. Integrar con Express
3. Autenticaci√≥n de socket
4. Emitir/recibir mensajes simples
```

### Fase 2: Frontend WebSocket (1-2 d√≠as)
```
1. Crear hook useChatWebSocket
2. Conectar componentes
3. Cargar historial de mensajes
4. Sincronizar en tiempo real
```

### Fase 3: Funcionalidades Avanzadas (2-3 d√≠as)
```
1. Indicador de escribiendo
2. Marcar como le√≠do
3. Editar/eliminar mensajes
4. Notificaciones desktop
5. Archivos adjuntos
```

### Fase 4: Pulido y Optimizaci√≥n (1-2 d√≠as)
```
1. Reconexi√≥n autom√°tica
2. Cach√© de mensajes
3. Paginaci√≥n de mensajes antiguos
4. Tests
```

---

## üìä TABLA DE M√ìDULOS NECESARIOS

| # | M√≥dulo | Ubicaci√≥n | Estado | Prioridad | Tipo |
|---|--------|-----------|--------|-----------|------|
| 1 | WebSocket Server | `backend/src/lib/websocket.ts` | ‚ùå CREAR | P0 | Backend |
| 2 | WebSocket Integration | `backend/src/server.ts` | ‚ö†Ô∏è MODIFICAR | P0 | Backend |
| 3 | Chat Hook | `web/src/hooks/use-chat-websocket.tsx` | ‚ùå CREAR | P0 | Frontend |
| 4 | Chat Component | `web/src/components/realtime-chat.tsx` | ‚ö†Ô∏è ACTUALIZAR | P0 | Frontend |
| 5 | Chat Page | `web/src/app/chat/page.tsx` | ‚ö†Ô∏è ACTUALIZAR | P0 | Frontend |
| 6 | Typing Indicator | `web/src/components/typing-indicator.tsx` | ‚ùå CREAR | P1 | Frontend |
| 7 | Connection Status | `web/src/components/connection-status.tsx` | ‚ùå CREAR | P1 | Frontend |
| 8 | Message Actions | `web/src/components/message-actions.tsx` | ‚ùå CREAR | P1 | Frontend |
| 9 | Endpoints Edit/Delete | `backend/src/server.ts` | ‚ùå AGREGAR | P1 | Backend |
| 10 | Notification Service | `backend/src/lib/notifications.ts` | ‚ùå CREAR | P2 | Backend |

---

## üìù ENDPOINTS QUE FALTAN AGREGAR

### Endpoints Requeridos

```typescript
// Marcar mensajes como le√≠do
PUT /mensajes/:id/marcar-leido

// Editar mensaje
PUT /mensajes/:id
Request: { cuerpo: string }

// Eliminar mensaje
DELETE /mensajes/:id

// Obtener conversaci√≥n espec√≠fica
GET /conversaciones/:id

// Actualizar conversaci√≥n
PUT /conversaciones/:id

// Eliminar conversaci√≥n
DELETE /conversaciones/:id

// Enviar archivo en chat
POST /mensajes/archivo

// Buscar mensajes
GET /conversaciones/:id/buscar?q=texto

// Notificaciones no le√≠das
GET /notificaciones/no-leidas
```

---

## üöÄ ORDEN DE TRABAJO RECOMENDADO

### SEMANA 1
**Lunes-Martes:**
- [ ] Crear WebSocket server en backend
- [ ] Integrar con Express
- [ ] Tests b√°sicos de conexi√≥n

**Mi√©rcoles-Jueves:**
- [ ] Crear hook `useChatWebSocket` en frontend
- [ ] Conectar componentes con real-time
- [ ] Cargar historial de mensajes

**Viernes:**
- [ ] Testing end-to-end
- [ ] Debugging y fixes
- [ ] Documentaci√≥n

### SEMANA 2
**Lunes-Martes:**
- [ ] Indicador de escribiendo
- [ ] Estados de entrega
- [ ] Marcar como le√≠do

**Mi√©rcoles-Jueves:**
- [ ] Editar/eliminar mensajes
- [ ] Notificaciones desktop
- [ ] Reconexi√≥n autom√°tica

**Viernes:**
- [ ] Optimizaci√≥n
- [ ] Performance testing
- [ ] Deploy a staging

---

## üîê CONSIDERACIONES DE SEGURIDAD

### JWT en WebSocket
```typescript
// Verificar token al conectar
ws.on('connection', (socket) => {
  const token = socket.handshake.auth.token;
  const decoded = jwt.verify(token, JWT_SECRET);
  socket.userId = decoded.id;
});
```

### Autorizaci√≥n
```typescript
// Verificar que usuario es participante de conversaci√≥n
const isParticipant = await prisma.participante_conversacion.findFirst({
  where: {
    conversacion_id: conversacionId,
    usuario_id: userId
  }
});

if (!isParticipant) {
  throw new Error('No autorizado');
}
```

### Validaci√≥n de mensajes
```typescript
// Sanitizar entrada
const mensaje = DOMPurify.sanitize(input);

// Limitar largo
if (mensaje.length > 5000) {
  throw new Error('Mensaje muy largo');
}

// Rate limiting
if (messagesInLastMinute > 30) {
  throw new Error('Demasiados mensajes');
}
```

---

## üìö RECURSOS Y DEPENDENCIAS

### Backend
```json
{
  "ws": "^8.14.0",
  "socket.io": "^4.7.0"
}
```

### Frontend
```json
{
  "socket.io-client": "^4.7.0"
}
```

### Alternativas
- **Socket.io**: M√°s f√°cil, incluye fallbacks
- **ws**: M√°s ligero, control total
- **Supabase Realtime**: Si quieres serverless

---

## üìã CHECKLIST FINAL

Cuando hayas terminado, verifica:

- [ ] WebSocket conecta exitosamente
- [ ] Mensajes se env√≠an en tiempo real
- [ ] Mensajes se persisten en BD
- [ ] Historial carga correctamente
- [ ] M√∫ltiples usuarios ven mensajes
- [ ] Desconexi√≥n/reconexi√≥n maneja bien
- [ ] Sin memory leaks
- [ ] Seguridad verificada
- [ ] Tests pasando
- [ ] Documentaci√≥n actualizada

---

**Resumen:** Necesitas implementar un sistema de WebSocket para mensaje en tiempo real, conectar frontend y backend, y agregar endpoints faltantes.

